в лекциях были даны 3 типа массивов:

- изменяемые (списки) - list()  
    
- неизменяемые (кортежи) - tuple()
- неупорядоченные, без повторений (множества) - set()

По аналогии с численными типами данных массивы можно переводить из одного типа в другой:  

![](https://ucarecdn.com/8803099c-6842-4d90-b3ef-840d1b4b831c/ "Image: https://ucarecdn.com/8803099c-6842-4d90-b3ef-840d1b4b831c/")

Этим пользуются для типичной операции удаления дубликатов из списка:

![](https://ucarecdn.com/b44731b5-97dd-496c-b3c5-296578e39ddf/ "Image: https://ucarecdn.com/b44731b5-97dd-496c-b3c5-296578e39ddf/")

Но почему же выше написано, что множество - неупорядоченный массив? До сих пор всё было в порядке.

Однако, рассмотрим простой пример:

![](https://ucarecdn.com/773dbd40-55f9-44d1-9eb8-23fa7c1f1c55/ "Image: https://ucarecdn.com/773dbd40-55f9-44d1-9eb8-23fa7c1f1c55/")

Причина такого поведения - механизм адресации для элементов множества. Для них используются не индексы (как в списке или кортеже), а хеши от значений. И хеши иногда могут быть упорядочены совсем иначе, нежели значения...


# frozenset

_Данный тип не изучался в лекциях, мы не будем его использовать._

Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет.  

```python
>>> a = set('qwerty')
>>> b = frozenset('qwerty')
>>> a == b
True
>>> True
True
>>> type(a - b)
<class 'set'>
>>> type(a | b)
<class 'set'>
>>> a.add(1)
>>> b.add(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no attribute 'add'
```


# Split()

Один из наиболее полезных методов, который будет очень часто использоваться в данном практикуме для формирования входных данных.

split() позволяет разрезать строку на подстроки, и возвращает список этих подстрок.

**Пример.**

```python
>>> splitted_line = "Ivanov Ivan Ivanovich".split()
>>> print splitted_line
['Ivanov', 'Ivan', 'Ivanovich']
```

Если не указан разделитель (как выше), то "разрезание" производится по пробелам, переносам строки и символам табуляции:

```python
>>> S = '''Fisrt string
>>> Second string
>>> Third string with tabs'''

>>> print S.split()
['Fisrt', 'string', 'Second', 'string', 'Third', 'string', 'with', 'tabs']

>>> print S.split(' ')
['Fisrt', 'string\nSecond', 'string\nThird', 'string\twith\ttabs']

>>> print S.split('\n')
['Fisrt string', 'Second string', 'Third string\twith\ttabs']

>>> print S.split('\t')
['Fisrt string\nSecond string\nThird string', 'with', 'tabs']
```

В качестве разделителя может использовать любой символ:  

```python
>>> S = 'Some string with text'
>>> print S.split('e')
['Som', ' string with t', 'xt']
```


# Join()

﻿Полезный метод для склеивания списка обратно в строку.  

Пример синтаксиса:

```python
' '.join(['Fisrt', 'second', 'third'])
```

  

![](https://ucarecdn.com/596a23db-8c9d-412e-8a53-17a9a2263035/ "Image: https://ucarecdn.com/596a23db-8c9d-412e-8a53-17a9a2263035/")

В качестве разделителя может служить любой символ:

![](https://ucarecdn.com/bbae178a-1eb9-499b-82ee-cde460c0abe4/ "Image: https://ucarecdn.com/bbae178a-1eb9-499b-82ee-cde460c0abe4/")

  

## Print(*List) в python3

В python3 есть 1 "хак", позволяющий выводить на печать списки без использования join (например, если вы работаете в консоли) - простановка символа "звёздочки" перед списком внутри функции print:

![](https://ucarecdn.com/ba57cf43-9e43-41b1-ab5a-6ade85dc9c13/)


# Обращения по индексу

Все примеры будут даны для списков, но для кортежей ситуация аналогична.

К элементу списка/кортежа всегда можно обратиться по его индексу (нумерация начинается с 0!):

```python
>>> L = ['one', 'two', 'three']
>>> L[1]
two
```

**Срезы**

Срез - это способ получить подмассив из оригинального массива.

Синтаксис:

```python
List[start_index:stop_index:step]
```

Например,

```python
>>> L = ['one', 'two', 'three', 'four', 'five', 'six']
>>> L[1:4:2]
['two', 'four']
```

- Начало среза - 1й элемент ('two')
- Окончание среза - 4й элемент, не включительно
- шаг среза - 2

Значения по-умолчанию:

- Начало среза - 0й элемент
- окончание среза - за пределами массива, т.е. включая ВСЕ элементы
- шаг - 1

Если нужно указать только начальное значение среза, например, получить все значения, начиная с определённого, то достаточно указать только его и 1 двоеточие (чтобы отличить от записи индекса):

```python
>>> L = ['one', 'two', 'three', 'four', 'five', 'six']
>>> L[3:]
['four', 'five', 'six']
```

Если необходимо указать только окончание или шаг среза, то можно опустить все предыдущие значения, но необходимо будет указать, соответствующее число двоеточий:

```python
>>> L = ['one', 'two', 'three', 'four', 'five', 'six']

>>> print L[:3]
['one', 'two', 'three']
>>> print L[::3]
['one', 'four']
```

**Отрицательные значения для срезов и индексов**

Отрицательные значения - важная фича.

Для индекса, начала и окончания списка, фактически это сокращённая запись от разницы между длиной списка и указанным числом

Т.е.

```python
L[-1]
```

эквивалентно

```python
L[len(L)-1]
```

Таким образом, запись L[-1], например, позволяет получить последний элемент списка (вне зависимости от длины этого списка).

**Пример:**

```python
>>> L = ['one', 'two', 'three', 'four', 'five', 'six']
>>> print L[-1:]
['six']
>>> print L[:-1]
['one', 'two', 'three', 'four', 'five']
```

  
Отрицательный шаг позволяет изменить порядок вывода элементов списка:

```python
>>> L = ['one', 'two', 'three', 'four', 'five', 'six']
>>> print L[::-1]
['six', 'five', 'four', 'three', 'two', 'one']
```


# Методы списков (List)

- **list.append**(x)Добавляет элемент в конец списка  
    
- **list.extend**(L)Расширяет список list, добавляя в конец все элементы списка L  
    
- **list.insert**(i, x)Вставляет на i-ый элемент значение x  
    
- **list.remove**(x)Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует  
    
- **list.pop**([i])Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент  
    
- **list.index**(x, [start [, end]])Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)  
    
- **list.count**(x)Возвращает количество элементов со значением x  
    
- **list.sort**([key=функция])Сортирует список на основе функции  
    
- **list.reverse**()Разворачивает список  
    
- **list.copy**()Поверхностная копия списка  
    
- **list.clear**()Очищает список  
    

[Подробнее](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html)


## Объединение списков  

Списки можно объединять с помощью оператора "+":

![](https://ucarecdn.com/3c25bc83-e0bf-4b5f-afde-690bd9d3022e/)


# map

Функция map позволяет применить какую-то функцию к каждому элементу списка.

Такая операция будет полезна для перевода большого числа чисел из строкового типа (например, после получения их из input() в целочисленный (int) или тип с плавающей точкой (float)).

Важно учитывать, что map возвращает не список, а итератор (что это такое мы обсудим позже). Поэтому имеет смысл [привести](https://stepik.org/lesson/52666/step/7 "Link: https://stepik.org/lesson/52666/step/7") результат к типу списка.

![](https://ucarecdn.com/4ac56b2d-590b-44a6-902e-096980ecb89c/ "Image: https://ucarecdn.com/4ac56b2d-590b-44a6-902e-096980ecb89c/")

map может работать с различными типами (а не только числами и строками), например, отсортируем числа в дочерних списках (но сами списки оставим на своих местах):

![](https://ucarecdn.com/9910e56d-e72f-4bcf-8b83-72626ab39ed8/)

**Примечание.** Функция map может принимать любую функцию, в том числе вашу собственную.


# zip

Полезная функция, для манипуляций со списками. Самое распространённое применение - создание нового списка из "пар" соответствующих элементов.

Следует учитывать, что zip возвращает итератор в python3 (об итераторах позднее) и непосредственно список в python2:

![](https://ucarecdn.com/3f01857a-c2d5-449a-9dcb-0d53a3613b5d/ "Image: https://ucarecdn.com/3f01857a-c2d5-449a-9dcb-0d53a3613b5d/")

Конечно же на самом деле далеко не обязательно пары. Если в zip передать несколько объектов, то он объединит в каждом кортеже по 1 элементу из каждого:

![](https://ucarecdn.com/dd6bd422-8991-4cb5-9e07-0591a4121417/ "Image: https://ucarecdn.com/dd6bd422-8991-4cb5-9e07-0591a4121417/")

_Т.к. на вход была передано 3 списка, то получился список троек._

  
Следует быть аккуратными с объектами разной длины, т.к. результат будет соответствовать минимальному списку.

Добавим список длины 4 (на 1 больше, чем остальные):

![](https://ucarecdn.com/9f47a2b1-ddab-4e10-9967-c784de441baf/ "Image: https://ucarecdn.com/9f47a2b1-ddab-4e10-9967-c784de441baf/")

_Как видим строка "четыре" потерялась..._

Передавать в zip можно не только списки, но и любые итерируемые объекты, например, [строки](https://stepik.org/lesson/58269/step/5 "Link: https://stepik.org/lesson/58269/step/5") и генераторы. Добавим индексы (начиная с 0), используя генератор range:

## 

![](https://ucarecdn.com/f692eba4-d52f-4d2f-ab56-df47c17b4a4c/ "Image: https://ucarecdn.com/f692eba4-d52f-4d2f-ab56-df47c17b4a4c/")

##   
zip(*[iter(s)] * n)  

﻿Конструкция для кластеризации.  

Например, для превращения плоского списка чисел от 1 до 9 в матрицу 3 на 3:

![](https://ucarecdn.com/2d62670e-c407-467b-b4bf-10539f8f0605/ "Image: https://ucarecdn.com/2d62670e-c407-467b-b4bf-10539f8f0605/")

n в этой формуле задаёт число элементов в 1 кортеже. Следует учитывать, что если элементов будет недостаточно для формирования целого кортежа, то он просто будет выброшен (например, числа от 1 до 8 формируют только 2 полных и 1 неполный кортежи по 3шт):

  

![](https://ucarecdn.com/9e0a0097-1901-4fcd-be27-76ec23f508af/)


# Копирование списков

Список - это изменяемый объект. По сути список - это набор ссылок на элементы (которые тоже могут быть объектами).

Это иногда приводит к ряду неприятных ситуаций:

![](https://ucarecdn.com/0c237067-8416-4c27-8ef6-5d227d55e56a/)

Мы изменили элемент в "скопированном" списке, а он изменился ещё и в оригинальном!

  

## Поверхностное копирование

Подходит для копирования одноуровневых списков, т.е. списков вида:

```python
L = [1, 'two', 3.0]
```

**1. метод copy()**

![](https://ucarecdn.com/59a92f26-7c2e-4f71-ac74-5f61677b3b1c/)

  

**2. срез по всем элементам [:]**

![](https://ucarecdn.com/42ef0a2f-a8be-4a62-acf7-acd17bf2990f/)

**3. Конструктор list()**

![](https://ucarecdn.com/40d4209d-2c30-47bd-97f0-e1aa489754f3/)

  

## А как же многоуровневые списки?

Т.е. списки списков:

```python
L = [[1, 2, 3], [4, 5, 6], [7, 8 ,9]]
```

К сожалению, ни один из выше упомянутых способов не гарантирует сохранности их содержимого:

![](https://ucarecdn.com/2a081606-866b-4b04-b0c2-738adbc2abb1/)

  

## Глубокое копирование

Можно всегда пройтись по дочерним элементам списка (и по их дочерним элементам), если необходимо в цикле. Однако есть более эффективный путь:

**4. функция deepcopy модуля copy**

[https://docs.python.org/3/library/copy.html](https://docs.python.org/3/library/copy.html#copy.deepcopy)  

![](https://ucarecdn.com/de880cb5-74ea-4d00-a477-291a326473d7/ "Image: https://ucarecdn.com/de880cb5-74ea-4d00-a477-291a326473d7/")

Т.е. процесс состоит из 2 частей:

1. импортируем модуль copy (или только функцию deepcopy из него)  
    
2. применяем функцию deepcopy к исходному списку, а полученный результат сохраняем в новую переменную  
    

Например:  

```python
from copy import deepcopy
L2 = deepcopy(L1)  
```