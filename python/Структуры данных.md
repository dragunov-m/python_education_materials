В Python есть несколько встроенных структур данных, каждая из которых имеет свои уникальные особенности и использование. Вот основные из них:

**Списки (Lists)**

- Являются изменяемыми последовательностями.
- Поддерживают добавление, удаление, изменение элементов.
- Предоставляют методы, такие как `append()`, `remove()`, `pop()`, `sort()`.
- Минус: Поиск элемента может быть медленным для больших списков.
- Пример:

```python
my_list = [1, 2, 3]
my_list.append(4)
my_list.remove(1)
```

**Кортежи (Tuples)**

- Неизменяемые последовательности, обычно используются для группировки разнородных данных.
- Поддерживают индексацию и итерации, но не изменение.
- Минус: Нельзя изменить после создания.
- Пример:

```python
my_tuple = (1, "Hello", 3.14)
print(my_tuple[1])
```

**Словари (Dictionaries)**

- Изменяемые коллекции пар ключ-значение.
- Поддерживают быстрый доступ, добавление и удаление элементов.
- Минус: Ключи должны быть уникальными и хешируемыми.
- Пример:

```python
my_dict = {"apple": 5, "banana": 2}
my_dict["orange"] = 3
```

**Множества (Sets)**

- Неупорядоченные коллекции уникальных элементов.
- Поддерживают операции над множествами, такие как объединение, пересечение.
- Минус: Не поддерживают индексированный доступ.
- Пример:

```python
my_set = {1, 2, 3}
my_set.add(4)
my_set.discard(1)
```

**Frozen Sets (Frozensets)**

- Неизменяемая версия множеств.
- Поддерживают операции над множествами, но не добавление или удаление элементов.
- Минус: Нельзя изменить после создания.
- Пример:

```python
my_frozenset = frozenset([1, 2, 3])
```

**Строки (Strings)**

- Неизменяемые последовательности символов.
- Поддерживают индексацию, срезы, конкатенацию.
- Минус: Не поддерживают прямое изменение символов.
- Пример:

```python
greeting = "Hello"
greeting = greeting + " World!"
```

**Стеки (Stacks)**

- Легко реализуемы через списки в Python.
- Поддерживают добавление и удаление элементов в порядке LIFO.
- Минус: Неоптимальны для больших данных из-за динамической природы списков.
- Пример:

```python
stack = []
stack.append(1)
stack.pop()
```

**Графы**

- Графы состоят из узлов (или вершин) и рёбер, соединяющих эти узлы.
- В Python графы часто представляются с помощью словарей и списков. Ключи словаря представляют узлы, а значения - списки соседних узлов.
- Пример:

```python
graph = {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A'], 'D': ['B']}
```

**Деревья**

- Реализуются через классы и объекты.
- Поддерживают иерархическую организацию данных.
- Минус: Требуют дополнительных структур для эффективного обхода и поиска.
- Пример:

```python
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.children = []
```

**Двоичные деревья поиска (BST)**

- Реализуются через классы и объекты.
- Поддерживают эффективный поиск, добавление, удаление.
- Минус: Неоптимальны без балансировки.
- Пример:

```python
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key
```

**Префиксные деревья (Tries)**

- Префиксное дерево - это вид поискового дерева, используемого для быстрого поиска слов в словаре, для автодополнения и других приложений, работающих с текстом.
- В узлах дерева хранятся символы, а пути от корня к узлам формируют слова или префиксы.
- Пример:

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False
```

**Хеш-функции**

- Хеш-функции используются для преобразования входных данных в значение фиксированной длины, которое обычно используется для ускорения поиска и сравнения данных.
- В Python модуль `hashlib` предоставляет доступ к различным хеш-функциям, таким как MD5, SHA1, SHA256.
- Пример:

```python
import hashlib
result = hashlib.sha256(b'Python').hexdigest()
```

**Символьные таблицы (Symbol Tables)**

- Символьная таблица - это структура данных, используемая в компиляторах и интерпретаторах для хранения информации о переменных, функциях и других идентификаторах.
- В Python символьные таблицы часто реализуются с использованием словарей, где ключами являются имена идентификаторов.
- Пример:

```python
symbol_table = {'x': 1, 'y': 2, 'func': lambda x: x + 1}
```

**Массивы (Arrays)**

- Эффективны для работы с большими объемами однотипных данных.
- Поддерживают быстрый доступ к элементам.
- Минус: Ограничены одним типом данных.
- Пример:

```python
from array import array
arr = array('i', [1, 2, 3, 4])
```

**Deque (collections.deque)**

- Поддерживают быстрое добавление и удаление с обеих концов.
- Подходят для реализации очередей и стеков.
- Минус: Сложнее в управлении, чем обычные списки.
- Пример:

```python
from collections import deque
d = deque([1, 2, 3])
d.appendleft(0)
d.pop()
```

**Counter**

- `collections.Counter` - это словарь подкласс, предназначенный для подсчета хешируемых объектов.
- Он особенно полезен для подсчёта вхождений элементов в последовательности.
- Пример использования:

```python
from collections import Counter
c = Counter(['apple', 'banana', 'apple', 'pear'])
print(c)  # Выведет: Counter({'apple': 2, 'banana': 1, 'pear': 1})
```

**OrderedDict**

- `collections.OrderedDict` - это словарь, который сохраняет порядок добавления ключей.
- С Python 3.7+, обычные словари также сохраняют порядок, но `OrderedDict` имеет дополнительные функции.
- Пример использования:

```python
from collections import OrderedDict
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
```

**DefaultDict**

- `collections.defaultdict` - это подкласс словаря, который вызывает фабричную функцию для предоставления значения по умолчанию для отсутствующего ключа.
- Очень полезен, когда нужны значения по умолчанию для новых ключей.
- Пример использования:

```python
from collections import defaultdict
dd = defaultdict(int)  # int() возвращает 0
dd['key'] += 1
```

### NamedTuple (collections.namedtuple)

- **Что такое**: `namedtuple` - это фабрика для создания подклассов кортежей с именованными полями.
- **Особенности**: Позволяет доступ к элементам по имени и индексу, улучшает читаемость кода.
- **Методы**: Поддерживает все методы кортежа, а также доступ к элементам по имени.
- **Пример кода**:

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(11, y=22)
print(p.x)  # 11
```

### ChainMap (collections.ChainMap)

- **Что такое**: `ChainMap` объединяет несколько словарей или других отображений в одно логическое целое.
- **Особенности**: Поиск ключей происходит последовательно в каждом из словарей. При изменении `ChainMap`, изменяется первый словарь.
- **Методы**: Основные методы словаря (`get`, `set`, `del` и т.д.).
- **Пример кода**:

```python
from collections import ChainMap

dict1 = {'one': 1, 'two': 2}
dict2 = {'three': 3, 'four': 4}
combined = ChainMap(dict1, dict2)
print(combined['three'])  # 3
```

### Heapq (heapq)

- **Что такое**: Модуль `heapq` предоставляет функции для реализации кучи на базе списка.
- **Особенности**: Поддерживает минимальную кучу, позволяя эффективно добавлять и удалять наименьший элемент.
- **Методы**: `heappush`, `heappop`, `heapify` и др.
- **Пример кода**:

```python
import heapq

heap = []
heapq.heappush(heap, 10)
heapq.heappush(heap, 1)
heapq.heappush(heap, 5)
print(heapq.heappop(heap))  # 1
```

### Bisect (bisect)

- **Что такое**: Модуль `bisect` предназначен для работы с отсортированными списками.
- **Особенности**: Позволяет быстро находить позиции вставки элементов, сохраняя порядок списка.
- **Методы**: `bisect_left`, `bisect_right`, `insort_left`, `insort_right`.
- **Пример кода**:

```python
import bisect

nums = [1, 3, 4, 4, 5]
bisect.insort(nums, 2)
print(nums)  # [1, 2, 3, 4, 4, 5]
```

### Weak References (weakref)

- **Что такое**: Модуль `weakref` позволяет создавать слабые ссылки на объекты.
- **Особенности**: Слабые ссылки не увеличивают счетчик ссылок объекта, позволяя ему быть удаленным сборщиком мусора.
- **Методы**: `ref`, `proxy`, `getweakrefcount` и др.
- **Пример кода**:

```python
import weakref

class MyClass:
    pass

obj = MyClass()
r = weakref.ref(obj)
print(r())  # <__main__.MyClass object at 0x...>
```

### Enum (enum.Enum)

- **Что такое**: Модуль `enum` предоставляет возможность создавать перечисления.
- **Особенности**: Перечисления улучшают читаемость и структуру кода, предоставляя именованные константы.
- **Методы**: Основные методы перечислений.
- **Пример кода**:

```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
print(Color.RED)  # Color.RED
```

### itertools модуль

- **Что такое**: Модуль `itertools` предоставляет множество итераторов для эффективной обработки последовательностей.
- **Особенности**: Включает функции для создания комбинаций, перестановок, бесконечных итераторов и других полезных конструкций.
- **Методы**: `chain`, `cycle`, `combinations`, `permutations` и др.
- **Пример кода**:

```python
import itertools

for num in itertools.chain([1, 2, 3], ['a', 'b']):
    print(num)  # 1, 2, 3, 'a', 'b'
```

### Functorial Dictionaries

- **Что такое**: Словари, которые генерируют значения для ключей на основе предоставленной функции при первом доступе к ключу.
- **Особенности**: Удобны для создания словарей с дефолтными значениями, особенно когда эти значения зависят от ключа.
- **Пример кода**:

```python
class FunctorialDict(dict):
    def __missing__(self, key):
        value = some_function(key)  # Генерация значения
        self[key] = value
        return value
```

### bytearray

- **Что такое**: `bytearray` - изменяемая последовательность байтов.
- **Особенности**: Позволяет изменять отдельные байты и эффективно работать с бинарными данными.
- **Пример кода**:

```python
arr = bytearray([1, 2, 3])
arr[1] = 4
print(arr)  # bytearray(b'\x01\x04\x03')
```

### memoryview

- **Что такое**: `memoryview` - объект, который предоставляет интерфейс в память для байтовых данных.
- **Особенности**: Эффективный способ работы с бинарными данными, не создавая копий.
- **Пример кода**:

```python
b = bytearray(b'hello')
mv = memoryview(b)
mv[1:4] = b'abc'
print(b)  # bytearray(b'haclo')
```

### queue.Queue

- **Что такое**: Класс `Queue` из модуля `queue` предназначен для создания очередей в многопоточных приложениях.
- **Особенности**: Потокобезопасная реализация очереди, подходит для обмена данными между потоками.
- **Пример кода**:

```python
from queue import Queue

q = Queue()
q.put('item')
print(q.get())  # 'item'
```

### **queue.PriorityQueue**

- **Чем является**: `PriorityQueue` — это класс очереди с приоритетом, который предоставляет возможность добавлять элементы с определённым приоритетом, так что элемент с наивысшим приоритетом обрабатывается первым.
- **Что поддерживает**: Поддерживает стандартные методы очереди, такие как `put()` для добавления и `get()` для извлечения элементов.
- **Методы**: `put(item, priority)`, `get()`, `empty()`, `full()`.
- **Особенности**: Порядок элементов определяется их приоритетом, а не порядком добавления.
- **Минусы**: Не подходит для ситуаций с высокой конкуренцией из-за блокировок.
- **Пример кода**:

```python
from queue import PriorityQueue

pq = PriorityQueue()
pq.put((2, "Medium Priority Task"))
pq.put((1, "High Priority Task"))
pq.put((3, "Low Priority Task"))

while not pq.empty():
    print(pq.get())
```

### **queue.LifoQueue**

- **Чем является**: `LifoQueue` представляет собой структуру данных типа стек (последний пришёл — первый ушёл).
- **Что поддерживает**: Методы для добавления (`put`) и извлечения (`get`) элементов.
- **Методы**: `put(item)`, `get()`, `empty()`, `full()`.
- **Особенности**: Элементы обрабатываются в обратном порядке по сравнению с очередью FIFO.
- **Минусы**: Подобно `PriorityQueue`, может быть неэффективен в ситуациях с высокой конкуренцией.
- **Пример кода**:

```python
from queue import LifoQueue

stack = LifoQueue()
stack.put("first")
stack.put("second")
stack.put("third")

while not stack.empty():
    print(stack.get())
```

### **collections.UserDict, UserList, UserString**

- **Чем являются**: Это обёртки вокруг стандартных структур данных Python (`dict`, `list`, `str`), которые упрощают создание подклассов.
- **Что поддерживают**: Все стандартные методы их встроенных аналогов.
- **Методы**: Зависят от типа структуры данных (`append`, `get`, `set` и т.д.).
- **Особенности**: Удобны для добавления специализированного поведения или расширения функциональности стандартных структур данных.
- **Минусы**: Могут быть избыточными для простых задач.
- **Пример кода**:

```python
from collections import UserDict

class MyDict(UserDict):
    def get(self, key, default=None):
        if key in self.data:
            return f"Found: {self.data[key]}"
        else:
            return f"Not found: {default}"

my_dict = MyDict({'one': 1, 'two': 2})
print(my_dict.get('three', 'default_value'))
```

## **asyncio.Queue**

- **Чем является**: Асинхронная очередь, используемая в асинхронном программировании для обмена данными между асинхронными задачами.
- **Что поддерживает**: Асинхронные методы для добавления (`put`) и извлечения (`get`) данных.
- **Методы**: `put(item)`, `get()`, `empty()`, `full()`.
- **Особенности**: Позволяет безопасно обмениваться данными между асинхронными задачами.
- **Минусы**: Требует понимания асинхронного программирования и управления задачами.
- **Пример кода**:

```python
import asyncio

async def producer(queue):
    for i in range(5):
        await queue.put(f"item {i}")

async def consumer(queue):
    while True:
        item = await queue.get()
        print(f"Consumed: {item}")

queue = asyncio.Queue()
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.gather(producer(queue), consumer(queue)))
```

### **contextvars.ContextVar**

- **Чем является**: Предоставляет переменные, значения которых уникальны для каждого контекста (например, в каждой задаче асинхронного выполнения).
- **Что поддерживает**: Установку и получение значений в зависимости от контекста.
- **Методы**: `set(value)`, `get(default)`.
- **Особенности**: Полезно для управления состоянием в асинхронных приложениях.
- **Минусы**: Требует понимания асинхронного программирования и контекстных переменных.
- **Пример кода**:

```python
import asyncio
from contextvars import ContextVar

var = ContextVar("var", default=0)

async def modify_var(value):
    var.set(value)
    await asyncio.sleep(1)
    print(f"Variable in task: {var.get()}")

async def main():
    task1 = asyncio.create_task(modify_var(1))
    task2 = asyncio.create_task(modify_var(2))
    await asyncio.gather(task1, task2)

asyncio.run(main())
```

### **dataclasses.dataclass**

- **Чем является**: Декоратор, который автоматически добавляет специальные методы, такие как `__init__`, `__repr__`, в классы для хранения данных.
- **Что поддерживает**: Автоматическое создание конструкторов, методов сравнения и других полезных методов.
- **Методы**: Автоматически созданные.
- **Особенности**: Упрощает создание классов для хранения данных и повышает читаемость кода.
- **Минусы**: Не подходит для создания сложных классов с динамическим поведением.
- **Пример кода**:

```python
from dataclasses import dataclass

@dataclass
class Product:
    name: str
    price: float

product = Product("Widget", 19.99)
print(product)
```

### **typing.NamedTuple и TypedDict**

- **Чем являются**: `NamedTuple` - это расширение кортежа с именованными полями, а `TypedDict` - это словарь с фиксированными типами для ключей и значений.
- **Что поддерживают**: Типизацию элементов, улучшение читаемости и поддержку статического анализа кода.
- **Методы**: Автоматически созданные.
- **Особенности**: Обеспечивают ясность и строгость в определении структур данных.
- **Минусы**: Могут быть избыточными для простых задач.
- **Пример кода**:

```python
from typing import NamedTuple, TypedDict

class Employee(NamedTuple):
    name: str
    age: int

class Movie(TypedDict):
    title: str
    year: int

emp = Employee("Alice", 30)
movie = Movie(title="Inception", year=2010)
```

### **array.array**

- Чем является: `array.array` — это структура данных, предоставляющая эффективное хранение и доступ к последовательностям числовых данных.
- Поддерживают: Поддерживает все базовые операции списка, но все элементы должны быть одного типа.
- Методы: методы включают `append`, `remove`, `pop`, `index` и др.
- Особенности: Более эффективны по памяти по сравнению со списками за счет однотипности данных.
- Минусы: Ограничены одним типом данных, менее гибкие чем списки.
- Пример кода:

```python
from array import array
arr = array('i', [1, 2, 3, 4])  # массив целых чисел
arr.append(5)
print(arr)  # array('i', [1, 2, 3, 4, 5])
```

### **mmap.mmap**

- Чем является: `mmap.mmap` представляет собой класс, который позволяет работать с файлами в памяти, что ускоряет операции чтения и записи.
- Поддерживают: Позволяет читать и изменять файлы непосредственно в памяти.
- Методы: включают `read`, `write`, `seek`, `close`.
- Особенности: Быстрый доступ и модификация файлов, особенно полезно для больших файлов.
- Минусы: Управление памятью становится более сложным, потенциальные проблемы с безопасностью данных.
- Пример кода:

```python
import mmap
# Открытие файла в режиме чтения
with open("example.txt", "r+b") as f:
    mm = mmap.mmap(f.fileno(), 0)
    print(mm.readline())  # чтение строки
    mm.close()
```

## Список активно используемых структур данны

1. **Списки (Lists)** - Активно используется
2. **Кортежи (Tuples)** - Активно используется
3. **Словари (Dictionaries)** - Активно используется
4. **Множества (Sets)** - Активно используется
5. **Frozen Sets (Frozensets)** - Иногда используется
6. **Строки (Strings)** - Активно используется
7. **Стеки (Stacks)** - Активно используется
8. **Графы** - Активно используется
9. **Деревья** - Активно используется
10. **Двоичные деревья поиска (Binary Search Trees, BST)** - Активно используется
11. **Префиксные деревья (Tries)** - Иногда используется
12. **Хеш-функции** - Активно используется
13. **Символьные таблицы (Symbol Tables)** - Активно используется
14. **Массивы (Arrays)** - Иногда используется
15. **Deque (collections.deque)** - Иногда используется
16. **Counter (collections.Counter)** - Иногда используется
17. **OrderedDict (collections.OrderedDict)** - Иногда используется
18. **DefaultDict (collections.defaultdict)** - Активно используется
19. **NamedTuple (collections.namedtuple)** - Иногда используется
20. **ChainMap (collections.ChainMap)** - Редко используется
21. **Heapq (heapq)** - Иногда используется
22. **Bisect (bisect)** - Иногда используется
23. **Weak References (weakref)** - Редко используется
24. **Enum (enum.Enum)** - Иногда используется
25. **itertools модуль** - Активно используется
26. **Functorial Dictionaries (Словари с функцией по умолчанию)** - Специфично используется
27. **bytearray** - Иногда используется
28. **memoryview** - Редко используется
29. **queue.Queue** - Иногда используется
30. **queue.PriorityQueue** - Редко используется
31. **queue.LifoQueue** - Редко используется
32. **collections.UserDict** - Редко используется
33. **collections.UserList** - Редко используется
34. **collections.UserString** - Редко используется
35. **asyncio.Queue** - Иногда используется
36. **contextvars.ContextVar** - Редко используется
37. **dataclasses.dataclass** - Активно используется
38. **typing.NamedTuple** - Иногда используется
39. **typing.TypedDict** - Иногда используется
40. **array.array** - Иногда используется   
41. **mmap.mmap** - Редко используется

## В каких случаях используются данные структуры

1. **Списки (Lists)**: Используются для хранения коллекций объектов, часто в случаях, где порядок и доступ к элементам по индексу важны.
    
2. **Кортежи (Tuples)**: Применяются для хранения неизменяемых коллекций разнородных данных, таких как записи из базы данных или возвращаемые значения функций.
    
3. **Словари (Dictionaries)**: Широко используются для хранения и доступа к данным через ключи, особенно в ситуациях, где требуется быстрый поиск или хранение пар ключ-значение.
    
4. **Множества (Sets)**: Используются для удаления дубликатов из коллекций, выполнения математических операций над множествами и в случаях, где важна уникальность элементов.
    
5. **Frozen Sets (Frozensets)**: Применяются для создания неизменяемых множеств, например, в качестве ключей словаря или для сохранения множества данных в неизменяемом виде.
    
6. **Строки (Strings)**: Основа для обработки и хранения текстовой информации в программировании.
    
7. **Стеки (Stacks)**: Используются в алгоритмах, обработке парсера, обратной польской записи в калькуляторах и для управления выполнением программ.
    
8. **Графы**: Применяются в алгоритмах маршрутизации, социальных сетях, организационных структурах и для представления сетевых структур.
    
9. **Деревья**: Используются в иерархических структурах данных, системах управления базами данных, для обработки и хранения данных в упорядоченной форме.
    
10. **Двоичные деревья поиска (Binary Search Trees, BST)**: Применяются для эффективного поиска и сортировки данных.
    
11. **Префиксные деревья (Tries)**: Используются в реализации словарей, автокомплита и системах быстрого поиска текста.
    
12. **Хеш-функции**: Основа для создания хеш-таблиц, обеспечения безопасности данных, криптографии и индексации.
    
13. **Символьные таблицы (Symbol Tables)**: Применяются в компиляторах и интерпретаторах для хранения информации о переменных и функциях.
    
14. **Массивы (Arrays)**: Используются для работы с большими объемами однотипных данных, особенно в числовых и научных вычислениях.
    
15. **Deque (collections.deque)**: Подходят для задач, где требуются операции вставки и удаления с обеих сторон структуры данных.
    
16. **Counter (collections.Counter)**: Используется для подсчета элементов, статистического анализа и обработки данных.
    
17. **OrderedDict (collections.OrderedDict)**: Подходит для случаев, когда необходимо сохранить порядок добавления элементов в словарь.
    
18. **DefaultDict (collections.defaultdict)**: Удобен для автоматического создания значений для отсутствующих ключей в словаре.
    
19. **NamedTuple (collections.namedtuple)**: Используется для улучшения читаемости кода, предоставляя доступ к элементам по имени.
    
20. **ChainMap (collections.ChainMap)**: Применяется для создания единого представления нескольких словарей.
    
21. **Heapq (heapq)**: Используется для реализации приоритетных очередей и алгоритмов, где требуется часто получать наименьший или наибольший элемент.
    
22. **Bisect (bisect)**: Подходит для работы с отсортированными списками, особенно когда требуется эффективное вставление элементов.
    
23. **Weak References (weakref)**: Используется для создания ссылок на объекты без предотвращения их автоматического удаления сборщиком мусора.
    
24. **Enum (enum.Enum)**: Подходит для создания перечислений, которые улучшают читаемость и организацию кода.
    
25. **itertools модуль**: Широко используется для эффективного и компактного создания итераторов в различных алгоритмах.
    
26. **Functorial Dictionaries**: Применяется в специализированных случаях, когда требуется автоматическая генерация значений для словаря.
    
27. **bytearray**: Используется для работы с изменяемыми последовательностями байтов, например, при обработке двоичных данных.
    
28. **memoryview**: Применяется для эффективного доступа к памяти и манипуляций с данными без копирования.
    
29. **queue.Queue**: Используется в многопоточном программировании для обмена данными между потоками.
    
30. **queue.PriorityQueue**: Применяется для реализации очередей с приоритетами, например, в планировщиках задач.
    
31. **queue.LifoQueue**: Используется как стек в многопоточных приложениях.
    
32. **collections.UserDict, UserList, UserString**: Применяются для создания пользовательских версий словарей, списков и строк со специальным поведением.
    
33. **asyncio.Queue**: Используется в асинхронном программировании для управления задачами и обмена данными.
    
34. **contextvars.ContextVar**: Применяется для хранения и управления контекстными переменными в асинхронном программировании.
    
35. **dataclasses.dataclass**: Широко используется для упрощения создания классов, особенно тех, что предназначены для хранения данных.
    
36. **typing.NamedTuple и TypedDict**: Используются для улучшения типизации и читаемости кода, особенно в больших и сложных системах.
    
37. **array.array**: Подходит для эффективного хранения и обработки больших массивов числовых данных.
    
38. **mmap.mmap**: Применяется для эффективной работы с файлами, особенно большого размера, путём отображения их в память.